(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{272:function(n,t,s){"use strict";s.r(t);var a=s(28),e=Object(a.a)({},(function(){var n=this,t=n.$createElement,s=n._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[s("h1",{attrs:{id:"this"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#this"}},[n._v("#")]),n._v(" this")]),n._v(" "),s("h4",{attrs:{id:"this-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#this-2"}},[n._v("#")]),n._v(" this")]),n._v(" "),s("h5",{attrs:{id:"为什么用this？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么用this？"}},[n._v("#")]),n._v(" 为什么用this？")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v("为了隐式传递对象引用，可以将API设计的更加简洁易于复用[当模式越来越复杂显示传递上下文对象会让代码越来越混乱]\n")])])]),s("h5",{attrs:{id:"this指向"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#this指向"}},[n._v("#")]),n._v(" this指向")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v("运行时绑定，谁调用指向谁 (ps:词法作用域是编写时绑定)，this的上下文取决于函数调用时的各种条件\n\n判断this\n1. new绑定：由new调用？==绑定到新创建到对象\n2. 显示绑定：由call或者apply(或者bing)调用？==绑定到指定的对象\n3. 隐式绑定：由上下文调用？==绑定到那个上下文对象\n4. 默认绑定：严格模式下==绑定到undefined，否则==绑定到全局对象\n5. 箭头函数的this根据外层词法作用域决定，==绑定在当前所属对象的顶级作用域\n（保护全局对象\n    ø = Object.create(null) ）\n")])])]),s("p",[n._v("this绑定规则（优先级：new绑定>显示绑定>隐式绑定>默认绑定）")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[n._v("new的过程\n\n1. 创建一个全新的对象\n2. 这个新对象会被执行[[原型]]连接\n3. 这个新对象会绑定函数调用的this\n4. 如果函数没有返回其他对象，那么new表达式的函数调用会自动返回这个新对象。\n\n默认绑定\n    非严格模式 window\n    严格模式 undefined\n隐式绑定\n    函数引用有上下文对象时,绑定到该上下文象(对内部包含函数引用)\n    ...隐式丢失\n显示绑定\n    call apply\n    硬绑定\n    ```\n    function bind(fn,obj){\n        return function(){\n            returnfn.apply(obj,arguments);\n        }\n    }\n    ```\n    ES5 bind\n    API调用的上下文(call apply实现)    \n\nnew绑定 \n    绑定到新对象上\n")])])]),s("p",[s("code",[n._v("bind fn.apply(obj,arguments)???")])])])}),[],!1,null,null,null);t.default=e.exports}}]);