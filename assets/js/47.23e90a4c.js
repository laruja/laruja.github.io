(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{292:function(t,s,n){"use strict";n.r(s);var a=n(28),e=Object(a.a)({},(function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"this"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#this"}},[t._v("#")]),t._v(" this")]),t._v(" "),n("ul",[n("li",[t._v("this作用")]),t._v(" "),n("li",[t._v("es6之前的this指向")]),t._v(" "),n("li",[t._v("es6之后的this指向")])]),t._v(" "),n("h3",{attrs:{id:"this作用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#this作用"}},[t._v("#")]),t._v(" this作用")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("为了隐式传递对象引用，可以将API设计的更加简洁易于复用，因为当模式越来越复杂显示传递上下文对象会让代码越来越混乱\n")])])]),n("h3",{attrs:{id:"es6之前的this"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#es6之前的this"}},[t._v("#")]),t._v(" es6之前的this")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("指向：运行时绑定，谁调用指向谁 (ps:词法作用域是编写时绑定)，this的上下文取决于函数调用时的各种条件")])]),t._v(" "),n("li",[n("p",[t._v("this绑定规则优先级：new绑定>显示绑定>隐式绑定>默认绑定")]),t._v(" "),n("ol",[n("li",[t._v("new绑定：由new调用？==绑定到新创建到对象")]),t._v(" "),n("li",[t._v("显示绑定：由call或者apply(或者bing)调用？==绑定到指定的对象")]),t._v(" "),n("li",[t._v("隐式绑定：由上下文调用？==绑定到那个上下文对象")]),t._v(" "),n("li",[t._v("默认绑定：严格模式下==绑定到undefined，否则==绑定到全局对象")])])]),t._v(" "),n("li",[n("p",[t._v("ECMAScript 3/5中 固定this方式：")]),t._v(" "),n("ol",[n("li",[t._v("将this值分配给封闭的变量 var that = this")])])])]),t._v(" "),n("h3",{attrs:{id:"es6之后的this指向"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#es6之后的this指向"}},[t._v("#")]),t._v(" es6之后的this指向")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("箭头函数的this根据外层词法作用域决定，==绑定在当前所属对象的顶级作用域。也就是说箭头函数不会创建自己的this，它只会从自己的作用域的上一层继承this。\n\n（保护全局对象\n    ø = Object.create(null) ）\n")])])]),n("h3",{attrs:{id:"new的过程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#new的过程"}},[t._v("#")]),t._v(" new的过程")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("1. 创建一个全新的对象\n2. 这个新对象会被执行[[原型]]连接\n3. 这个新对象会绑定函数调用的this\n4. 如果函数没有返回其他对象，那么new表达式的函数调用会自动返回这个新对象。\n\n默认绑定\n    非严格模式 window\n    严格模式 undefined\n隐式绑定\n    函数引用有上下文对象时,绑定到该上下文象(对内部包含函数引用)\n    ...隐式丢失\n显示绑定\n    call apply\n    硬绑定\n    ```\n    function bind(fn,obj){\n        return function(){\n            returnfn.apply(obj,arguments);\n        }\n    }\n    ```\n    ES5 bind\n    API调用的上下文(call apply实现)    \n\nnew绑定 \n    绑定到新对象上\n")])])])])}),[],!1,null,null,null);s.default=e.exports}}]);