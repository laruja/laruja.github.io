# ES6+
- es6  ECMAScript2015 较大更新，详见[ES6入门教程](https://es6.ruanyifeng.com/)
- es7  ECMAScript2016 [增加数组includes()es6], Math.pow的简写语法**
- es8  ECMAScript2017 在异步操作、Object、String能力上做了进一步增强，让代码编写更加效率
- es9  ECMAScript2018 主要解决了遍历中异步、异步的归一操作等问题，
                        也提供了对象的拷贝、筛选功能
                        提升正则的处理能力
- es10 ECMAScript2019 无大幅改动
                        JSON问题修复，数组、字符串、对象、函数等能力进一步增强
                        新增BigInt数据类型(精确计算)

### ES6  
- [箭头函数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions) ()=>{} :
    1. 简短。比函数表达式更简洁，替代匿名函数
    2. 没有自己的this、arguments、super、new.target。this继承自作用域的上一层this
        - 不适合用做方法
        - 不能用做构造器，和new一起使用报错
        - 无prototype属性
        - 不能用做函数生成器，yield不能在箭头函数中使用(?)

- [class类](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes)


```js
const arr = [1,2,3];
arr.indexOf(2)
arr.include(4)
```

### ES7 es2016        
```js
Math.pow(2,3)
2**3
```
### es8 es2017
1. 允许函数参数尾逗号
```js
/**async await更加语义化
与同步迭代器区别是返回 next => Promise

操作异步代码
1.嵌套回调
2.Promise
3.Generators
4.async await
*/
async function fn(){
    await Promise.resolve();
}

async function add(num){
    const a = 1;
    return num + a;
}
console.log(add(2));
add(2).then(res=>{
    console.log(res);
});

function promiseFn(){
    return new Promise((resolve,reject)=>{
        setTimeout(()=>{
            resolve("resolve");
           // reject("错误信息");
        },1500);
    });
}
// 1 捕获异常的另一种方法 
async function fn(){
    try{
        await promiseFn();
        console.log("错误下不会执行");
    }catch(err){
        console.log(err);
    }
}
// 2 捕获异常的另一种方法 
async function fn(){
    await promiseFn();
    console.log("错误下不会执行");
}
fn().catch(err=>{
    console.log(err)
});
// 3 捕获异常下面代码可以执行 截留
async function fn(){
    await promiseFn().catch(err=>{
        console.log(err);
    });
    console.log("错误下会执行");
}
fn();

// 多个await异步命令
function promiseFn1(){
    return new Promise((resolve,reject)=>{
        setTimeout(()=>{
            resolve("resolve");
           // reject("错误信息");
        },1500);
    });
}
function promiseFn2(){
    return new Promise((resolve,reject)=>{
        setTimeout(()=>{
            resolve("resolve");
           // reject("错误信息");
        },2000);
    });
}
async function fn1(){
    console.time("fn1");
    let res1 = await promiseFn1();
    let res2 = await promiseFn2();
    console.timeEnd("fn1");
}
fn1();
// promise.all() 同时执行
async function fn2(){
    console.time("fn2");
    let [res1,res2] = await Promise.all([promiseFn1(),promiseFn2()]) ;
    console.timeEnd("fn2");
}
fn2();
// Object.values() vs Object.keys()
//只包含自身值，不包含继承来的值...没验证
const obj = {name:"lrj",age:"18"};
console.log(Object.keys(obj).map(key=>obj[key]));
console.log(Object.values(obj));

//Object.entries() vs for...in(会枚举原型链中的属性)
const obj = {name:"lrj",age:"18"};
console.log(Object.entries(obj));
console.log(Object.entries("lrj"));//非对象强制转化成对象
//遍历对象键值
for(const [key,value] of Object.entries(obj)){
    console.log(`${key}-${value}`);
}
Object.entries(obj).forEach([key,value]=>{
    console.log(`${key}-${value}`);
});

// String Padding
//1. String.prototype.padStart(targetLength,[padString]) 字符串开头结尾添加
//2. String.prototype.padEnd
console.log('abc'.padStart(4,"d"))
console.log('abc'.padStart(5,"🍎"))
console.log('abc'.padStart(7,"🍎"))
//es8结尾允许逗号 如版本检测很实用
function fn(
    para1,
    para2,
){
    console.log(para1, para2);
}
fn(1,2);

let obj={
    n:'',
    n:'',
}
// Object.getOwnPropertyDescriptors();
const obj = {
    name:"lrj",
    get fn(){
        return "fn";
    }
};
console.log(Object.getOwnPropertyDescriptors(obj));
//!!!!!!! SharedArrayBuffer 与 Atomics
 //js单线程，而这两个共享内存和原子操作可以实现多线程
 //高级特效 js引擎核心改进
 //提高代码性能 高并发
 //共享内存主要思想：把多线程引入js
 // 新的全局对象 SharedArrayBuffer,
    // js主线程、web-worker线程可共享内存。使得数据传输更快
    // 之前用postMessage()不同线程之间进行数据传递
   //带来的问题：多线程竞争，=>解决办法Atomics加锁 


```

### es9 es2018

### es10 es2019
1. function toString()返回函数代码本身(以前会省略注释和空格)
2. function try{}catch(err可省略){}
### es11 es2020