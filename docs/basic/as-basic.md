# 数据结构&算法

## 数据结构
- 按逻辑结构分类
    集合(无逻辑关系)
    线性结构(线性表，一对一的关系)
        一维数组
        队列
        栈
    非线性结构
        树
        图
        多维数组(c c++中的多维数组)
- 按存储结构分类
    顺序存储结构(连续的存储空间)
    链式存储结构(存储空间不连续，指针指向下一个元素)
    索引存储结构(典型map，由两部分组成：key和value，通过key找到value)
    散列存储结构(元素之间无联系，用于堆)

- 逻辑--理论->存储：
**线性[表、栈、队列、串]***精*--理论->**顺序、链接、散列、索引**
**树[二叉树、森林]**明白*----理论->**内存、外存(可忽略)**
**图[有向、无向、DAG]**了解*--理论->**外排序、B+树、倒排**

- 基本数据结构及衍生结构
1. 集合：同一元素出现一次， js中set
2. 线性结构：数组（除了第一个和最后一个，其他位置都有一个前驱和一个后继，一一对应(朝一个方向取)）
3. 树状结构：层级，一对多
4. 图(网状结构)

- 线性表实现：顺序存储 链式存储

## 算法
- 基本特征
1. 有穷性
2. 确切性
3. 输入项
4. 输出项
5. 可行性
- 衡量算法好坏
1. 复杂度：时间复杂度；空间复杂度
2. 正确性
3. 可读性
4. 健壮性
- 必须掌握的基本算法
1. 枚举
2. 递归
3. 基本排序
4. 基本查找

### 枚举算法
核心思想：枚举所有的可能
满足条件：1. 可预先确定候选答案的数量
        2. 候选答案的范围在求解之前必须有一个确定的集合
特点：1. 简单粗暴，暴力枚举所有可能，尽可能的尝试所有方法
    2. 速度可能很慢
    3. 实现最简单，并且得到的结果总是正确的      

### 递归算法
核心思想：通过重复将问题分解为同类子问题而解决问题的方法
特点：1. 函数可以通过调用自身来进行递归
    2. 递归可以完全取代循环
组成部分：1. 递归主题，即循环解决问题的代码
        2. 递归的跳出条件，不能一直递归下去，需要完成一定条件后跳出

### 排序算法
排序法 | 最佳时间复杂度 |  平均时间复杂度 |  最差时间复杂度 |  空间复杂度 |  稳定性   
-|-|-|-|-|-
冒泡排序 | n | $n^2$ | $n^2$ | 1 | yes |  
插入排序 | n | $n^2$ | $n^2$ | 1 | yes |  
选择排序 | $n^2$ | $n^2$ | $n^2$ | 1 | no |  
二叉树排序 | $nlogn$ | $nlogn$ | $nlogn$ | 1 | yes |  
快速排序 | $nlogn$ | $nlogn$ | $n^2$ | $logn$~n | no |  
堆排序 | $nlogn$ | $nlogn$ | $nlogn$ | 1 | no |  
希尔排序 | $nlogn$ | $nlogn$ | $n^2$ | 1 | no |  

### 查找算法
查找算法 | 平均时间复杂度 |  查找条件  
-|-|-
顺序查找 | n | 无序或有序队列 |
二分查找(折半查找) | $nlogn$ | 有序数组 |
二叉排序树查找 | $nlogn$ | 二叉排序树 |
哈希表法(散列表) | 1 | 先创建哈希表(散列表) |
分块查找 | $nlogn$ | 无序或有序队列 |










### 列表
关键词：元素，空列表
特点：元素不多，不适合查找排序运算，一种最自然的数据组织方式
现实中例子：购物清淡 待办事项列表
迭代器的优点：
    1. 访问元素不必关心底层数据结构；
    2. 增加删除元素比for灵活；
    3. 访问列表里的元素提供了统一的方法

### 
- 查找
### 二分法查找
```js
/**
 * 二分法查找
 */
function binarySearch(date, arr, start, end) {
    if (start > end) {
        return -1;
    }
    var mid = Math.floor((end + start) / 2);
    if (data == arr[mid]) {
        return mid;
    } else if (data < arr[mid]) {
        return binarySearch(data, arr, start, mid - 1);
    } else {
        return binarySearch(data, arr, mid + 1, end);
    }
}
```